# Go 依赖注入工具 Wire：从初学到精通

## 目录

1.  [什么是 Wire？](#什么是-wire)
2.  [为什么使用 Wire？](#为什么使用-wire)
3.  [安装 Wire](#安装-wire)
4.  [Wire 的基本用法](#wire-的基本用法)
    -   [定义依赖关系](#定义依赖关系)
    -   [创建 Provider 函数](#创建-provider-函数)
    -   [创建 Injector](#创建-injector)
    -   [生成代码](#生成代码)
5.  [进阶用法](#进阶用法)
    -   [绑定接口到具体实现](#绑定接口到具体实现)
    -   [结构体字段注入](#结构体字段注入)
    -   [清理函数（Cleanup）](#清理函数cleanup)
    -   [Provider Sets](#provider-sets)
6.  [最佳实践](#最佳实践)
7.  [参考资料](#参考资料)

## 什么是 Wire？

`Wire` 是 Google 开发的一个依赖注入（Dependency Injection,
DI）工具，用于 Go
语言。它通过代码生成的方式来实现依赖注入，而不是使用反射或其他运行时机制。相比于手动管理依赖关系，`Wire`
可以帮助你更轻松地管理和维护复杂的依赖关系。

## 为什么使用 Wire？

1.  **编译时检查**：`Wire`
    在编译时生成代码，因此可以捕获依赖注入中的错误，而不需要等到运行时。
2.  **减少样板代码**：手动管理依赖关系可能会导致大量的样板代码，`Wire`
    可以自动生成这些代码。
3.  **易于维护**：当你的项目变得复杂时，依赖关系也会变得更加复杂。`Wire`
    可以帮助你更好地组织和维护这些依赖。

## 安装 Wire

首先，你需要安装 `Wire` 工具。你可以通过以下命令安装：

``` bash
go install github.com/google/wire/cmd/wire@latest
```

确保 `$GOPATH/bin` 或者 `$GOBIN` 在你的 `PATH`
环境变量中，这样你就可以直接运行 `wire` 命令。

## Wire 的基本用法

### 定义依赖关系

假设我们有一个简单的应用程序，包含以下几个部分：

-   `MessageService`：负责发送消息。
-   `Logger`：负责记录日志。
-   `App`：主应用程序，依赖于 `MessageService` 和 `Logger`。

#### Logger

``` go
// logger.go
package main

type Logger struct{}

func NewLogger() *Logger {
return &Logger{}
}

func (l *Logger) Log(msg string) {
println(msg)
}
```

#### MessageService

``` go
// message_service.go
package main

type MessageService struct {
logger *Logger
}

func NewMessageService(logger *Logger) *MessageService {
return &MessageService{logger: logger}
}

func (m *MessageService) SendMessage(msg string) {
m.logger.Log("Sending message: " + msg)
}
```

#### App

``` go
// app.go
package main

type App struct {
messageService *MessageService
}

func NewApp(messageService *MessageService) *App {
return &App{messageService: messageService}
}

func (a *App) Run() {
a.messageService.SendMessage("Hello, World!")
}
```

### 创建 Provider 函数

在上面的代码中，我们已经为 `Logger`、`MessageService` 和 `App`
创建了构造函数（即 `NewLogger`、`NewMessageService` 和
`NewApp`）。这些构造函数就是 `Provider` 函数。

### 创建 Injector

接下来，我们需要创建一个 `wire.go`
文件，定义如何将这些依赖项组合在一起。

``` go
// wire.go
//go:build wireinject
// +build wireinject

package main

import (
"github.com/google/wire"
)

func InitializeApp() *App {
wire.Build(NewLogger, NewMessageService, NewApp)
return nil
}
```

### 生成代码

现在我们可以运行 `wire` 命令来生成代码：

``` bash
wire
```

这将会生成一个 `wire_gen.go` 文件，内容类似于：

``` go
// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

func InitializeApp() *App {
logger := NewLogger()
messageService := NewMessageService(logger)
app := NewApp(messageService)
return app
}
```

这个文件包含了 `InitializeApp` 函数的实现，`Wire`
自动生成了依赖注入的逻辑。

### 使用生成的代码

最后，在 `main.go` 中，我们可以使用 `InitializeApp` 函数来启动应用程序：

``` go
// main.go
package main

func main() {
app := InitializeApp()
app.Run()
}
```

运行程序后，你会看到输出：

    Sending message: Hello, World!

## 进阶用法

### 绑定接口到具体实现

在实际项目中，我们通常会使用接口来定义服务的行为，而不是直接依赖于具体的实现。`Wire`
支持将接口绑定到具体的实现类。

假设我们有一个 `config` 文件，里面是各个配置的结构体。
``` go
// conf/config.go
package conf

type Config struct {
	Redis *RedisConfig
	MySQL *MySQLConfig
	Mongo *MongoConfig
}

type RedisConfig struct {
	Addr     string
	Password string
	DB       int
}

type MySQLConfig struct {
	DSN string // 数据库连接字符串
}

type MongoConfig struct {
	URI string // MongoDB 连接 URI
}

```

项目中使用了MongoDB，mysql，redis

mongo配置如下
``` go
// pkg/xmongo/mongo.go
package xmongo

import (
	"context"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"test/wireTest2/conf"
)

type MongoClient struct {
	Client *mongo.Client
}

func NewMongoClient(mongoConfig *conf.MongoConfig) (*MongoClient, error) {
	clientOptions := options.Client().ApplyURI(mongoConfig.URI)
	client, err := mongo.Connect(context.TODO(), clientOptions)
	if err != nil {
		return nil, err
	}
	return &MongoClient{Client: client}, nil
}
```

mysql配置如下
``` go
// pkg/xmysql/mysql.go
package xmysql

import (
	"database/sql"
	_ "github.com/go-sql-driver/mysql"
	"test/wireTest2/conf"
)

type MySQLClient struct {
	DB *sql.DB
}

func NewMySQLClient(mysqlConfig *conf.MySQLConfig) (*MySQLClient, error) {
	db, err := sql.Open("mysql", mysqlConfig.DSN)
	if err != nil {
		return nil, err
	}
	return &MySQLClient{DB: db}, nil
}
```

假设我们有一个 `Cache` 接口，并且 Redis 是它的具体实现。

``` go
// pkg/cache/cache.go
package cache

type Cache interface {
Get(key string) (string, error)
Set(key string, value string) error
}
```

然后我们在 `xredis` 包中实现这个接口：

``` go
// pkg/xredis/redis.go
package xredis

import (
"context"
"github.com/go-redis/redis/v8"
"test/wireTest2/conf"
)

type RedisCache struct {
Client *redis.Client
}

func NewRedisCache(redisConfig *conf.RedisConfig) *RedisCache {
client := redis.NewClient(&redis.Options{
Addr:     redisConfig.Addr,
Password: redisConfig.Password,
DB:       redisConfig.DB,
})
return &RedisCache{Client: client}
}

func (r *RedisCache) Get(key string) (string, error) {
return r.Client.Get(context.Background(), key).Result()
}

func (r *RedisCache) Set(key string, value string) error {
return r.Client.Set(context.Background(), key, value, 0).Err()
}
```

我们有一个server将各种配置放在一起并启动项目
``` go
// cmd/server/server.go
package main

import (
	"fmt"
	"test/wireTest2/pkg/cache"
	"test/wireTest2/pkg/xmongo"
	"test/wireTest2/pkg/xmysql"
)

//type Server struct {
//	Redis *xredis.RedisCache
//	MySQL *xmysql.MySQLClient
//	Mongo *xmongo.MongoClient
//}

type Server struct {
	Redis cache.Cache
	MySQL *xmysql.MySQLClient
	Mongo *xmongo.MongoClient
}

func (s *Server) Start() {
	fmt.Println("Server started!")
	// 在这里可以使用 Redis、MySQL 和 MongoDB 客户端
}


```

在 `wire.go` 中，我们可以使用 `wire.Bind` 将 `Cache` 接口绑定到
`RedisCache` 实现：

``` go
// cmd/server/wire.go
//go:build wireinject
// +build wireinject

package main

import (
	"github.com/google/wire"
	"test/wireTest2/conf"
	"test/wireTest2/pkg/cache"
	"test/wireTest2/pkg/xmongo"
	"test/wireTest2/pkg/xmysql"
	"test/wireTest2/pkg/xredis"
)

//func InitializeServer(redisConf *conf.RedisConfig, mysqlConf *conf.MySQLConfig, mongoConf *conf.MongoConfig) (*Server, error) {
//	wire.Build(
//		xredis.NewRedisCache, // 提供 RedisCache 实现
//		xmysql.NewMySQLClient,
//		xmongo.NewMongoClient,
//		wire.Struct(new(Server), "*"),
//	)
//	return nil, nil
//}

func InitializeServer(redisConf *conf.RedisConfig, mysqlConf *conf.MySQLConfig, mongoConf *conf.MongoConfig) (*Server, error) {
	wire.Build(
		xredis.NewRedisCache, // 提供 RedisCache 实现
		wire.Bind(new(cache.Cache), new(*xredis.RedisCache)), // 绑定接口到实现
		xmysql.NewMySQLClient,
		xmongo.NewMongoClient,
		wire.Struct(new(Server), "*"),
	)
	return nil, nil
}


```

### 结构体字段注入

如果你有一个结构体，并且希望自动注入它的字段，可以使用
`wire.Struct`。`wire.Struct` 会自动为结构体的字段注入依赖。

假设我们有一个 `App` 结构体，它依赖于多个服务：

``` go
// cmd/server/main.go
package main

import (
"your_project/pkg/cache"
"your_project/pkg/xmysql"
"your_project/pkg/xmongo"
)

type App struct {
Cache  cache.Cache
MySQL  *xmysql.MySQLClient
Mongo  *xmongo.MongoClient
MyService *Service
}

func (a *App) Start() {
println("App started!")
a.MyService.DoSomething()
}
```

在 `wire.go` 中，我们可以使用 `wire.Struct` 来自动注入 `App` 的字段：

``` go
// cmd/server/wire.go
//go:build wireinject
// +build wireinject

package main

import (
"your_project/conf"
"your_project/pkg/cache"
"your_project/pkg/xmysql"
"your_project/pkg/xredis"
"your_project/pkg/xmongo"
"github.com/google/wire"
)

func InitializeApp(config *conf.Config) (*App, error) {
wire.Build(
xredis.NewRedisCache,
wire.Bind(new(cache.Cache), new(*xredis.RedisCache)),
xmysql.NewMySQLClient,
xmongo.NewMongoClient,
NewService,
wire.Struct(new(App), "*"), // 自动注入 App 的所有字段
)
return nil, nil
}
```

### 清理函数（Cleanup）

有些依赖项可能需要在程序结束时进行清理操作，例如关闭数据库连接或释放资源。`Wire`
支持返回一个清理函数，用于在依赖注入完成后执行清理操作。

假设我们需要在 MySQL 客户端关闭时执行清理操作：

``` go
// pkg/xmysql/mysql.go
package xmysql

import (
"database/sql"
_ "github.com/go-sql-driver/mysql"
"test/wireTest3/conf"
)

type MySQLClient struct {
DB *sql.DB
}

func NewMySQLClient(mysqlConfig *conf.MySQLConfig) (*MySQLClient, func(), error) {
db, err := sql.Open("mysql", mysqlConfig.DSN)
if err != nil {
return nil, nil, err
}

    cleanup := func() {
        db.Close()
        println("MySQL connection closed")
    }

    return &MySQLClient{DB: db}, cleanup, nil
}
```

在 `wire.go` 中，`Wire` 会自动处理清理函数：

``` go
// cmd/server/wire.go
//go:build wireinject
// +build wireinject

package main

import (
	"github.com/google/wire"
	"test/wireTest3/conf"
	"test/wireTest3/pkg/cache"
	"test/wireTest3/pkg/xmongo"
	"test/wireTest3/pkg/xmysql"
	"test/wireTest3/pkg/xredis"
)

func InitializeServer(redisConf *conf.RedisConfig, mysqlConf *conf.MySQLConfig, mongoConf *conf.MongoConfig) (*Server, func(), error) {
	wire.Build(
		xredis.NewRedisCache, // 提供 RedisCache 实现
		wire.Bind(new(cache.Cache), new(*xredis.RedisCache)), // 绑定接口到实现
		xmysql.NewMySQLClient,
		xmongo.NewMongoClient,
		wire.Struct(new(Server), "*"),
	)
	return nil, nil, nil
}

```

在 `main.go` 中，我们可以调用清理函数：

``` go
// cmd/server/main.go
package main

func main() {
config := &conf.Config{
Redis: conf.RedisConfig{
Addr:     "localhost:6379",
Password: "",
DB:       0,
},
MySQL: conf.MySQLConfig{
DSN: "user:password@tcp(127.0.0.1:3306)/dbname",
},
Mongo: conf.MongoConfig{
URI: "mongodb://localhost:27017",
},
}

    app, cleanup, err := InitializeApp(config)
    if err != nil {
        panic(err)
    }
    defer cleanup() // 确保在程序结束时执行清理操作

    app.Start()
}
```

### Provider Sets

当你的项目变得复杂时，可能会有很多依赖项。为了简化 `wire.Build`
的调用，你可以将相关的依赖项组合成一个 `ProviderSet`。

假设我们有多个服务，每个服务都有自己的依赖项。我们可以将它们分组为不同的
`ProviderSet`。

``` go
// pkg/xredis/provider_set.go
package xredis

import (
"your_project/pkg/cache"
"github.com/google/wire"
)

var ProviderSet = wire.NewSet(
NewRedisCache,
wire.Bind(new(cache.Cache), new(*RedisCache)),
)
```

``` go
// pkg/xmysql/provider_set.go
package xmysql

import "github.com/google/wire"

var ProviderSet = wire.NewSet(NewMySQLClient)
```

``` go
// pkg/xmongo/provider_set.go
package xmongo

import "github.com/google/wire"

var ProviderSet = wire.NewSet(NewMongoClient)
```

然后在 `wire.go` 中，我们可以使用这些 `ProviderSet`：

``` go
// cmd/server/wire.go
//go:build wireinject
// +build wireinject

package main

import (
	"github.com/google/wire"
	"test/wireTest4/conf"
	"test/wireTest4/pkg/xmongo"
	"test/wireTest4/pkg/xmysql"
	"test/wireTest4/pkg/xredis"
)

func InitializeServer(redisConf *conf.RedisConfig, mysqlConf *conf.MySQLConfig, mongoConf *conf.MongoConfig) (*Server, func(), error) {
	wire.Build(
		xredis.ProviderSet,
		xmysql.ProviderSet,
		xmongo.ProviderSet,
		wire.Struct(new(Server), "*"),
	)
	return nil, nil, nil
}

```

## 最佳实践

1.  **保持依赖关系简单**：尽量避免过于复杂的依赖关系，保持依赖树的清晰。
2.  **使用接口**：尽量使用接口来定义服务的行为，而不是直接依赖于具体的实现。
3.  **合理使用 Provider Sets**：当依赖项较多时，使用 `ProviderSet`
    来简化 `wire.Build` 调用。
4.  **清理资源**：对于需要清理的资源（如数据库连接），务必返回清理函数。

## 参考资料

-   [Wire 官方文档](https://github.com/google/wire)
-   [Go 语言依赖注入详解](https://blog.golang.org/wire)
