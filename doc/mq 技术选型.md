### mq 技术选型

#### 前言

在分布式系统中，我们广泛运用消息中间件进行系统间的数据交换，便于异步解耦

#### 概念

##### MQ简介

MQ,message queue,消息队列，就是指保存消息的一个容器。具体的定义这里就不类似于数据库、缓存等，用来保护数据的。当然，与数据库、缓存等产品比较，也有自己一些特点，具体的特点后文会做详细的介绍。

现在常见的MQ组件有ActiveMQ、RabbitMQ、RocketMQ、ZeroMQ、MetaMQ,当然近年来火热的kafka从某些场景来说，也是MQ,当然kafka的功能更加强大，不同的MQ都有自己的特点和优势。

##### MQ特点

1.先进先出

不能先进先出，都不能说是队列了。消息队列的顺序在入队的时候就基本已经确定了，一般是不需要人工干预的。而且，最重要的是，数据是只有一条数据在使用中。这也是MQ在诸多场景被使用的原因。

2.发布订阅

发布订阅是一种很高效的处理方式，如果不发生阻塞，基本可以当作是同步操作。这种处理方式非常有效的提升服务器的利用率，这样的应用场景非常广泛。

3.持久化

持久化确保MQ的使用不只是一个部分场景的辅助工具，而是让MQ能像数据库一样存储核心的数据

4.分布式

在现在大流量、大数据的使用场景下，只支持单体应用的服务器软件基本是无法使用的，支持分布式的部署，才能被广泛使用。而且，MQ的定位就是一个高性能的中间件。

#### kafka

优点：吞吐量非常大，性能非常好，集群高可用

缺点： 会丢失数据，功能比较单一

使用场景：日志分析、大数据采集

#### RabbitMQ

优点：消息可靠性高，功能全面

缺点：吞吐量比较低，消息积累会严重影响性能，erlang语言不好定制

使用场景：小规模场景

#### RocketMQ

优点：高吞吐、高性能、高可用，功能非常全面

缺点：开源版功能不如云上商业版。官方文档和周边生态还不够成熟，客户端只支持java

使用场景：几乎全部场景



#### kafka是什么

kafka是一种高吞吐量、分布式、基于发布/订阅的消息系统，最初由linkedln公司开发，使用scala语言编写，目前是apache的开源项目

- broker:  kafka 服务器，负责消息存储和转发
- topic:  消息类别，kafka按照topic来分类消息
- partition：topic的分区，一个topic可以包含多个partition, topic消息保存在各个partition上
- offset: 消息在日志中的位置，可以理解消息在partition上的偏移量，也是代表该消息的唯一序号
- producer: 消息生产者
- consumer：消息消费者
- consumer group: 消费者分组，每个consumer必须属于一个group
- zookeeper： 保存着集群broker、topic、partition等meta数据；另外还负责broker故障发现。partition leader选举，负载均衡等功能。

#### kafka为什么吞吐量高

kafka的生产者采用的是**异步发送**消息机制，当发送一条消息时，消息并没有发送到broker而是缓存起来，然后直接向业务返回成功，当缓存的消息达到**一定数量**时再**批次发送**给broker。这种做法减少了网络io，从而提高了消息发送的吞吐量，但是如果消息生产者宕机，会导致**消息丢失**，业务出错，所以理论上kafka利用此机制*提高了性能却降低了可靠性*。

#### 为什么kafka的速度那么快

**kafka依赖于文件系统来保存和缓冲消息的**。在其他消息队列RabbitMQ中，使用的是内存作为默认的存储介质，而磁盘作为备选介质，以此来实现高吞吐和低延时的效果；redis则是完全依赖于内存实现。那么为什么kafka采用这种持久化的形式还能提供如此有竞争力的性能呢？

1. kafka对写操作的优化

   首先kafka在同一个topic partition中的数据是**有序的**，kafka设计的时候，就只支持在文件末尾进行追加，而不支持修改操作，属于典型的顺序写入操作，操作系统对顺序读写做了深层次的优化--预读和后写（将一个大磁盘块读入内存，将很多小逻辑的写操作在内存中完成后，一次性将这块数据写入磁盘）。有关研究表明，对磁盘的顺序写入速度远远大于对磁盘的随机写入，甚至还快过了对内存的随机写入。

2. kafka对读操作的优化

   kafka在读取得时候使用了**零拷贝**技术，降低对文件的拷贝次数，一定程度上提升了速度。

3. kafka大量使用了页缓存

   前面对读写操作的优化，使得kafka能承载吞吐量也不容小视，但这并不是kafka在全局性能上具备竞争力的全部因素。接下来介绍的是**页缓存**，kafka是如何借助操作系统的帮助提升性能的。

   

   页缓存是操作系统对数据文件的读写提供的**一种缓冲技术**，目的是为了减少i/o操作的次数。

   当进程读取某个文件的时候，操作系统会先查看待读写的数据是否在页缓存中，如果在则直接返回给进程，如果不在则从磁盘读取后先写入页缓存，然后再将数据返回给进程。

   当进程写入某个文件的时候，操作系统也会查看所需操作的页是否在也缓存中，如果存在则进行写入，如果不在则从磁盘中读取后再进行相关写入操作，被修改后的页，操作系统会再合适的时间内刷入磁盘来保证数据一致性。

   

   **kafka 大量使用页缓存，这也是kafka实现高性能的原因之一**。对于一个进程来说，他会在进程内部缓存所需要的数据，然而这些数据很有可能也缓存在操作系统的页缓存中，也就是这一部分数据被缓存了两次，就算kafka服务重启，页缓存内的数据也还是存在，但进程的数据则需要重新加载。这也在一定程度上能简化代码，而且维护页缓存和文件的一致性问题交给操作系统完成会比进程内维护要更加的安全、高效。

   

   虽然kafka的消息加载到页缓存中后，由操作系统择机刷入磁盘，但是kafka也还是提供了同步刷盘和间接性刷盘的功能，这些功能可以通过控制参数来实现。同步刷盘确实可以实现数据的可靠性，但是并不建议这样做，提高消息的可靠性应该由副本机制来实现，而不是由严重损耗性能的同步刷盘来实现。

   

   #### 常见主流MQ直接的对比

   | 特性                    | activeMQ                                                     | rabbitMQ                                                     | rocketMQ                                                     | kafka                                                        |
   | ----------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
   | 成熟度                  | 成熟                                                         | 成熟                                                         | 比较成熟                                                     | 成熟的日志领域                                               |
   | 时效性                  |                                                              | 微秒级                                                       | 毫秒级                                                       | 毫秒级                                                       |
   | 社区活跃度              | 低                                                           | 高                                                           | 高                                                           | 高                                                           |
   | 单机吞吐量              | 万级                                                         | 万级                                                         | 10万级                                                       | 10万级                                                       |
   | topic数量对吞吐量的影响 |                                                              |                                                              | topic可以达到几百、几千个的级别，吞吐量会有较小幅度的下降这是rocketMQ的一大优势，在同等机器下，可以支撑大量的topic | topic从几十个到几百个的时候，吞吐量会大幅度下降，所以在同等机器下，kafka尽量保证topic数量不要过多。如果要支撑大规模的topic，需要增加更多的机器资源 |
   | 可用性                  | 高，基于主从架构实现高可用性                                 | 高，基于主从架构实现高可用性                                 | 非常高，分布式架构                                           | 非常高，kafka是分布式的，，一个数据多个副本，少数机器宕机，不会丢失数据，不导致不可用 |
   | 消息可靠性              | 有较低的概率丢失数据                                         |                                                              | 经过参数优化配置，可以做到0丢失                              | 经过参数优化配置，消息可以做到0丢失                          |
   | 功能支持                | MQ领域的功能及其完备                                         | 基于erlang开发，所以并发能力很强，性能极其好，延时很低       | MQ功能较为完善，还是分布式的，扩展性好                       | 功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准 |
   | 优势劣势总结            | 非常成熟，功能强大，在业内大量的公司以及项目中都有用到，偶尔会有较低概率丢失消息。现在社区及国内应用越来越少，几个月才发布一个版本，主要基于解耦和异步来用，较少在大规模吞吐的场景中使用 | erlang语言开发，性能极其好，延时很低；MQ功能比较完备而且开源提供的管理页面非常好用，社区相对活跃，每个月都有几个版本，在国内一些互联网公司近几年用的也比较多，但吞吐量低一些，是因为他做的实现机制比较重，而且erlang开发，偶尔会有一些问题，很难去看懂源码，公司对这个东西的掌控很弱，基本只能依赖开源社区的快速维护和修复bug | 接口简单易用，在阿里大规模应用过，可以做到大规模吞吐，性能好，分布式扩展也很方便，社区维护也可以，可靠性和可用性都是ok的，支持复杂的mq业务场景，源码是java，可以自己阅读源码，定制自己公司的MQ,可以掌控。社区活跃度一般，文档相对来说简单一些，接口不是按照标准的JMS规范走的，有些系统要迁移需要修改大量代码。阿里出台的技术有被抛弃、社区黄掉的风险，公司有技术实力的话，用rocketMQ挺好 | kafka的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级的延时，极高的可用性以及可靠性，而且分布式可以任意扩展。同时kafka最好是支撑较少的topic数量即可，保证其超高吞吐量。劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中一级日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集 |

   

 #### 选择哪种消息中间件考虑

1. activeMQ已经不推荐使用了，因为社区活跃度很低，没什么人再去维护了。一旦使用过程中出现了问题，比较难找到解决办法；
2. rabbitMQ现在是使用的比较多的，吞吐量也达到万级，而且延时低，最好的一个优点是它提供了一个后台管理系统，对于中小型公司来说很有用；同时目前来看，社区活跃度较高。缺点就是开发语言使用的是erlang语言，对于java开发者来说，erlang语言比较难以看懂，不能深入的研究，只能简单使用。
3. rocketMQ是阿里开源的，现在社区也比较活跃，并且是java语言开发的，支持分布式集群。但是有被弃用的风险，一旦阿里什么时候不维护了，那么就有可能被废弃掉。如果是有能力的大公司还好，可以自己专研源码，自己维护，如果是小公司的话，那么就被坑了。
4. kafka主要用在大数据领域。它的主要优点是吞吐量大，同时也是分布式的。

https://blog.csdn.net/chaochao2113/article/details/127378685



